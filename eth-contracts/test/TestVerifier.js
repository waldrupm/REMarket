const expect = require('chai').expect;
const truffleAssert = require('truffle-assertions');

// define a variable to import the <Verifier> or <renamedVerifier> solidity contract generated by Zokrates
const verifierContract = artifacts.require('Verifier');

// - use the contents from proof.json generated from zokrates steps
const jsonProof = require('../../zokrates/Coin3-9/proof.json');
let admin;
let fakeProof;

contract('Verifier', (accounts) => {
  // Test verification with correct proof
  before(async() => {
    admin = accounts[0];
    verifierInstance = await verifierContract.new({from: admin});
    fakeProof = buildProof();
    console.log(fakeProof);
});

  it('should verify a correct proof and emit the correct event', async () => {
    let tx = await verifierInstance.verifyTx(
      fakeProof.proof.a,
      fakeProof.proof.b,
      fakeProof.proof.c,
      fakeProof.inputs
    );
    truffleAssert.eventEmitted(tx, 'Verified', (event) => {
      return expect(event.s).to.deep.equal("Transaction successfully verified.");
    });
  });
    
// Test verification with incorrect proof
  it('should not verify an incorrect proof and not emit verified event', async () => {
    let tx = await verifierInstance.verifyTx(
      fakeProof.proof.c,
      fakeProof.proof.b,
      fakeProof.proof.a,
      [4,0]
    );
    truffleAssert.eventNotEmitted(tx, 'Verified');
  });

});

const buildProof = function() {
  return  {
    "proof": {
      "a": [web3.utils.toBN(jsonProof.proof.a[0]).toString(), web3.utils.toBN(jsonProof.proof.a[1]).toString()],
      "b": [[web3.utils.toBN(jsonProof.proof.b[0][0]).toString(), web3.utils.toBN(jsonProof.proof.b[0][1]).toString()],
            [web3.utils.toBN(jsonProof.proof.b[1][0]).toString(), web3.utils.toBN(jsonProof.proof.b[1][1]).toString()]],
      "c": [web3.utils.toBN(jsonProof.proof.c[0]).toString(), web3.utils.toBN(jsonProof.proof.c[1]).toString()]
    },
    "inputs": jsonProof.inputs
  };
};

